"""
YCB CLI - YouTube Channel Builder Command Line Interface

A Click-based command-line interface for managing YouTube channel content creation
and automation using the YCB (YouTube Channel Builder) system.
"""

import click
import os
from pathlib import Path
from typing import Optional

from ..config import settings


@click.group()
@click.version_option(version="0.1.0", prog_name="ycb")
@click.option("--config", "-c", help="Configuration file path")
@click.option("--output-dir", "-o", help="Output directory for generated content")
@click.pass_context
def cli(ctx, config: Optional[str], output_dir: Optional[str]):
    """
    YCB - YouTube Channel Builder CLI
    
    Automate YouTube channel management with AI-powered content creation.
    """
    # Ensure that ctx.obj exists and is a dict
    ctx.ensure_object(dict)
    
    # Store configuration in context
    if config:
        ctx.obj['config_file'] = config
    
    if output_dir:
        ctx.obj['output_dir'] = output_dir
        # Update settings
        settings.ycb_output_dir = output_dir


@cli.group()
def script():
    """Generate and manage video scripts."""
    pass


@script.command("generate")
@click.argument("topic", required=True)
@click.option("--length", "-l", default="medium", 
              type=click.Choice(["short", "medium", "long"]),
              help="Script length (short: 2-3min, medium: 5-8min, long: 10-15min)")
@click.option("--style", "-s", default="educational",
              type=click.Choice(["educational", "entertaining", "tutorial", "review"]),
              help="Script style and tone")
@click.option("--output", "-o", help="Output file path for the generated script")
@click.pass_context
def generate_script(ctx, topic: str, length: str, style: str, output: Optional[str]):
    """
    Generate a video script for the given TOPIC.
    
    TOPIC: The main subject or theme for the video script
    
    Example:
        ycb script generate "How to Start a YouTube Channel"
    """
    click.echo(f"[*] Generating {length} {style} script for topic: '{topic}'")
    
    try:
        # Generate script data
        script_data = {
            "topic": topic,
            "length": length,
            "style": style
        }
        
        # TODO: Implement actual script generation
        click.echo("[!] Script generation is not yet fully implemented.")
        click.echo(f"    Topic: {topic}")
        click.echo(f"    Length: {length}")
        click.echo(f"    Style: {style}")
        
        # Determine output path
        output_dir = ctx.obj.get('output_dir', settings.ycb_output_dir)
        if not output:
            # Create a safe filename from topic
            safe_topic = "".join(c for c in topic if c.isalnum() or c in (' ', '-', '_')).rstrip()
            safe_topic = safe_topic.replace(' ', '_')
            output = f"{output_dir}/scripts/{safe_topic}_{length}_{style}.md"
        
        # Ensure output directory exists
        os.makedirs(os.path.dirname(output), exist_ok=True)
        
        click.echo(f"[>] Script will be saved to: {output}")
        
        # For now, create a placeholder script
        with open(output, 'w', encoding='utf-8') as f:
            f.write(f"""# Script: {topic}

**Style:** {style}
**Length:** {length}
**Generated by:** YCB CLI

## Introduction
[Script content will be generated here]

## Main Content
[Main content sections will be generated here]

## Conclusion
[Conclusion will be generated here]

---
*Generated by YCB (YouTube Channel Builder)*
""")
        
        click.echo("[+] Script generation completed!")
        
    except Exception as e:
        click.echo(f"[-] Error generating script: {str(e)}", err=True)
        raise click.ClickException(f"Script generation failed: {str(e)}")


@cli.command("upload")
@click.argument("video_file", type=click.Path(exists=True, readable=True))
@click.option("--title", "-t", help="Video title (defaults to filename)")
@click.option("--description", "-d", help="Video description")
@click.option("--privacy", "-p", default="private",
              type=click.Choice(["private", "public", "unlisted"]),
              help="Video privacy setting")
@click.option("--tags", help="Comma-separated list of video tags")
@click.pass_context
def upload_video(ctx, video_file: str, title: Optional[str], 
                description: Optional[str], privacy: str, tags: Optional[str]):
    """
    Upload a video file to YouTube.
    
    VIDEO_FILE: Path to the video file to upload
    
    Example:
        ycb upload video.mp4 --title "My Video" --privacy public
    """
    click.echo(f"[*] Preparing to upload video: {video_file}")
    
    try:
        # Validate video file
        video_path = Path(video_file)
        if not video_path.exists():
            raise click.ClickException(f"Video file not found: {video_file}")
        
        # Get file info
        file_size = video_path.stat().st_size
        file_size_mb = file_size / (1024 * 1024)
        
        click.echo(f"[>] Video file: {video_path.name}")
        click.echo(f"[>] File size: {file_size_mb:.2f} MB")
        
        # Set default title if not provided
        if not title:
            title = video_path.stem.replace('_', ' ').replace('-', ' ').title()
        
        click.echo(f"[>] Title: {title}")
        click.echo(f"[>] Privacy: {privacy}")
        
        if description:
            click.echo(f"[>] Description: {description[:100]}...")
        
        if tags:
            tag_list = [tag.strip() for tag in tags.split(',')]
            click.echo(f"[>] Tags: {', '.join(tag_list)}")
        
        # TODO: Implement actual YouTube upload
        click.echo("[!] YouTube upload is not yet fully implemented.")
        
        # Create video metadata
        video_data = {
            "file_path": str(video_path),
            "title": title,
            "description": description or "",
            "privacy": privacy,
            "tags": tags.split(',') if tags else []
        }
        
        click.echo("[+] Video upload prepared! (Implementation pending)")
        
    except Exception as e:
        click.echo(f"[-] Error uploading video: {str(e)}", err=True)
        raise click.ClickException(f"Video upload failed: {str(e)}")


@cli.command("config")
@click.option("--show", is_flag=True, help="Show current configuration")
@click.option("--validate", is_flag=True, help="Validate configuration settings")
def config_command(show: bool, validate: bool):
    """Manage YCB configuration settings."""
    
    if show:
        click.echo("[*] Current YCB Configuration:")
        click.echo(f"    Output Directory: {settings.ycb_output_dir}")
        click.echo(f"    Max Videos/Day: {settings.ycb_max_videos_per_day}")
        click.echo(f"    Default Privacy: {settings.ycb_default_privacy}")
        click.echo(f"    Auto Publish: {settings.ycb_auto_publish}")
        
        # Show API key status (masked)
        def mask_key(key: Optional[str]) -> str:
            if not key:
                return "[-] Not set"
            return f"[+] Set ({key[:8]}...)"
        
        click.echo("\n[*] API Keys:")
        click.echo(f"    OpenAI: {mask_key(settings.openai_api_key)}")
        click.echo(f"    YouTube Client ID: {mask_key(settings.youtube_client_id)}")
        click.echo(f"    ElevenLabs: {mask_key(settings.elevenlabs_api_key)}")
        click.echo(f"    Supabase URL: {mask_key(settings.supabase_url)}")
    
    if validate:
        click.echo("[*] Validating configuration...")
        is_valid = settings.validate_required_settings()
        
        if is_valid:
            click.echo("[+] Configuration is valid!")
        else:
            click.echo("[-] Configuration is incomplete. Please check your .env file.")
            click.echo("    Required: OpenAI API key, YouTube credentials, ElevenLabs API key, Supabase credentials")


@cli.command("status")
@click.option("--json", "as_json", is_flag=True, help="Output status as JSON")
def status(as_json: bool):
    """Show YCB system status and information."""
    import json as json_lib

    status_data = {
        "version": "0.1.0",
        "output_dir": settings.ycb_output_dir,
        "output_dir_exists": os.path.exists(settings.ycb_output_dir),
        "configured": settings.validate_required_settings(),
        "settings": {
            "max_videos_per_day": settings.ycb_max_videos_per_day,
            "default_privacy": settings.ycb_default_privacy,
            "auto_publish": settings.ycb_auto_publish
        },
        "api_keys": {
            "openai": bool(settings.openai_api_key),
            "youtube": bool(settings.youtube_client_id),
            "elevenlabs": bool(settings.elevenlabs_api_key),
            "supabase": bool(settings.supabase_url and settings.supabase_key)
        }
    }

    if as_json:
        click.echo(json_lib.dumps(status_data, indent=2))
        return

    click.echo("[*] YCB - YouTube Channel Builder")
    click.echo(f"    Version: {status_data['version']}")
    click.echo(f"    Output Directory: {status_data['output_dir']}")

    # Check if output directory exists
    if status_data['output_dir_exists']:
        click.echo("    Output directory: [+] Exists")
    else:
        click.echo("    Output directory: [-] Not found (will be created)")

    # Configuration status
    status_icon = "[+]" if status_data['configured'] else "[-]"
    click.echo(f"    Configuration: {status_icon} {'Ready' if status_data['configured'] else 'Incomplete'}")

    # API Keys status
    click.echo("\n    API Keys:")
    for key, is_set in status_data['api_keys'].items():
        icon = "[+]" if is_set else "[-]"
        click.echo(f"      {key}: {icon}")


@cli.command("daemon")
@click.option("--interval", "-i", default=60, type=int,
              help="Check interval in seconds (default: 60)")
@click.option("--once", is_flag=True, help="Run once and exit")
def daemon(interval: int, once: bool):
    """
    Run YCB as a background daemon for 24/7 operation.

    The daemon monitors the pipeline queue and processes pending jobs.

    Example:
        ycb daemon --interval 30
    """
    import time
    import signal
    import sys

    running = True

    def signal_handler(sig, frame):
        nonlocal running
        click.echo("\n[*] Shutdown signal received, stopping daemon...")
        running = False

    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    click.echo("[*] YCB Daemon Starting...")
    click.echo(f"    Check interval: {interval}s")
    click.echo(f"    Mode: {'single run' if once else 'continuous'}")
    click.echo("")

    # Verify configuration
    if not settings.supabase_url or not settings.supabase_key:
        click.echo("[-] Supabase not configured, running in local mode")
        db_connected = False
    else:
        try:
            from supabase import create_client
            client = create_client(settings.supabase_url, settings.supabase_key)
            # Test connection
            client.table('ycb_agent_status').select('count').limit(1).execute()
            click.echo("[+] Connected to Supabase")
            db_connected = True
        except Exception as e:
            click.echo(f"[-] Supabase connection failed: {e}")
            db_connected = False

    iteration = 0
    while running:
        iteration += 1
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")

        click.echo(f"[{timestamp}] Daemon check #{iteration}")

        try:
            # Check for pending pipeline jobs
            if db_connected:
                try:
                    result = client.table('ycb_video_pipeline')\
                        .select('*')\
                        .eq('status', 'pending')\
                        .limit(5)\
                        .execute()

                    pending_jobs = len(result.data) if result.data else 0
                    click.echo(f"    Pending jobs: {pending_jobs}")

                    # Process jobs (placeholder)
                    for job in (result.data or []):
                        click.echo(f"    [>] Would process: {job.get('topic', 'unknown')}")
                        # TODO: Implement actual job processing

                except Exception as e:
                    click.echo(f"    [-] Error checking jobs: {e}")
            else:
                click.echo("    [!] Running without database (local mode)")

            # Update heartbeat
            if db_connected:
                try:
                    from datetime import datetime, timezone
                    client.table('ycb_agent_status').upsert({
                        'agent_name': 'ycb_daemon',
                        'status': 'running',
                        'last_heartbeat': datetime.now(timezone.utc).isoformat(),
                        'metadata': {'iteration': iteration}
                    }, on_conflict='agent_name').execute()
                except Exception:
                    pass  # Heartbeat failure is non-fatal

        except Exception as e:
            click.echo(f"    [-] Daemon error: {e}")

        if once:
            click.echo("[*] Single run complete, exiting.")
            break

        # Sleep until next check
        click.echo(f"    Sleeping {interval}s...")
        time.sleep(interval)

    click.echo("[*] YCB Daemon stopped.")


@cli.command("pipeline")
@click.argument("topic", required=True)
@click.option("--output", "-o", help="Output directory for generated content")
@click.option("--dry-run", is_flag=True, help="Show what would be done without executing")
def pipeline(topic: str, output: Optional[str], dry_run: bool):
    """
    Run the full content pipeline for a TOPIC.

    This generates script, thumbnail, and prepares upload package.

    Example:
        ycb pipeline "How to Wire a Motor" --output ./my_video/
    """
    output_dir = output or os.path.join(settings.ycb_output_dir, topic.replace(' ', '_'))

    click.echo(f"[*] YCB Pipeline: {topic}")
    click.echo(f"    Output: {output_dir}")
    click.echo(f"    Mode: {'DRY RUN' if dry_run else 'EXECUTE'}")
    click.echo("")

    steps = [
        ("Generate Script", "script.json"),
        ("Generate Thumbnail", "thumbnail.png"),
        ("Generate Voice", "narration.mp3"),
        ("Create Metadata", "metadata.json"),
    ]

    for i, (step_name, step_output) in enumerate(steps, 1):
        status = "[DRY]" if dry_run else "[TODO]"
        click.echo(f"  {i}. {step_name} -> {step_output} {status}")

    if not dry_run:
        os.makedirs(output_dir, exist_ok=True)

        # Create placeholder files
        with open(os.path.join(output_dir, "pipeline.log"), 'w') as f:
            f.write(f"Pipeline started for: {topic}\n")
            f.write(f"Status: Placeholder - full implementation pending\n")

        click.echo("")
        click.echo(f"[+] Pipeline directory created: {output_dir}")
        click.echo("[!] Full pipeline implementation pending")
    else:
        click.echo("")
        click.echo("[*] Dry run complete. Use without --dry-run to execute.")


if __name__ == "__main__":
    cli()